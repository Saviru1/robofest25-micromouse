#include <Arduino.h>

// Motor driver pins
#define IN1 33
#define IN2 15
#define IN3 25
#define IN4 27
#define PWMA 32
#define PWMB 26
#define STBY 12

// Encoder pins
#define ENCODER_A_LEFT 19
#define ENCODER_B_LEFT 16
#define ENCODER_A_RIGHT 18
#define ENCODER_B_RIGHT 17

// TOF Sensors (example pins, you should use your actual sensor pins)
#define TOF_SENSOR_FRONT 13
#define TOF_SENSOR_LEFT 4
#define TOF_SENSOR_RIGHT 14

// IR Sensor pin (to detect final destination)
#define IR_SENSOR_PIN 5

// Constants for encoder counts (adjust according to your motor's specifications)
#define PULSES_PER_REVOLUTION 1440   // Example: Adjust based on your N20 motor encoder
#define WHEEL_DIAMETER 0.06          // Example: 60mm diameter wheel
#define WHEEL_CIRCUMFERENCE (PI * WHEEL_DIAMETER)  // Circumference of the wheel

// PID constants (tune these values based on your bot's behavior)
float Kp = 0.5;
float Ki = 0.1;
float Kd = 0.05;

// Target distance in mm (e.g., 180mm per cell)
float targetDistance = 180; 
float targetEncoderCounts = (targetDistance / WHEEL_CIRCUMFERENCE) * PULSES_PER_REVOLUTION; // Convert distance to encoder counts

// Movement history (for shortest path)
String movementHistory[100];
int historyIndex = 0;

// Grid representation of the environment (example)
#define GRID_SIZE 5
int grid[GRID_SIZE][GRID_SIZE] = {{0, 0, 1, 0, 0},
                                   {0, 0, 1, 0, 0},
                                   {0, 0, 0, 0, 0},
                                   {0, 1, 1, 0, 0},
                                   {0, 0, 0, 0, 0}};

// Current position of the bot (example starting point)
int currentX = 0, currentY = 0;

// Goal position (destination)
int goalX = 4, goalY = 4;

// Variables for PID control
float errorLeft = 0, previousErrorLeft = 0, integralLeft = 0, derivativeLeft = 0;
float errorRight = 0, previousErrorRight = 0, integralRight = 0, derivativeRight = 0;
float motorSpeedLeft = 0, motorSpeedRight = 0;
volatile int encoderCountsLeft = 0;
volatile int encoderCountsRight = 0;

// Motor control functions
void moveForward() {
  digitalWrite(IN1, HIGH);
  digitalWrite(IN2, LOW);
  digitalWrite(IN3, HIGH);
  digitalWrite(IN4, LOW);
}

void moveBackward() {
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, HIGH);
  digitalWrite(IN3, LOW);
  digitalWrite(IN4, HIGH);
}

void turnLeft() {
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, HIGH);
  digitalWrite(IN3, HIGH);
  digitalWrite(IN4, LOW);
}

void turnRight() {
  digitalWrite(IN1, HIGH);
  digitalWrite(IN2, LOW);
  digitalWrite(IN3, LOW);
  digitalWrite(IN4, HIGH);
}

void stopCar() {
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, LOW);
  digitalWrite(IN3, LOW);
  digitalWrite(IN4, LOW);
  analogWrite(PWMA, 0);
  analogWrite(PWMB, 0);
}

void applyPID() {
  // Left motor PID control
  errorLeft = targetEncoderCounts - encoderCountsLeft;
  integralLeft += errorLeft;
  derivativeLeft = errorLeft - previousErrorLeft;
  motorSpeedLeft = Kp * errorLeft + Ki * integralLeft + Kd * derivativeLeft;
  previousErrorLeft = errorLeft;

  // Right motor PID control
  errorRight = targetEncoderCounts - encoderCountsRight;
  integralRight += errorRight;
  derivativeRight = errorRight - previousErrorRight;
  motorSpeedRight = Kp * errorRight + Ki * integralRight + Kd * derivativeRight;
  previousErrorRight = errorRight;

  // Apply motor speed
  motorSpeedLeft = constrain(motorSpeedLeft, 0, 255);  // Ensure speed is within PWM limits
  motorSpeedRight = constrain(motorSpeedRight, 0, 255);

  analogWrite(PWMA, motorSpeedLeft);
  analogWrite(PWMB, motorSpeedRight);
}

// Flood Fill Algorithm for Pathfinding
void floodFill(int x, int y) {
  // Boundary checks and wall check
  if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE || grid[x][y] == 1) {
    return;  // Out of bounds or wall
  }

  // If the destination is found, update the movement sequence
  if (x == goalX && y == goalY) {
    grid[x][y] = 2;  // Mark as visited
    movementHistory[historyIndex++] = "Goal Reached";
    return;
  }

  grid[x][y] = 2;  // Mark as visited

  // Try to move in all 4 directions (up, down, left, right)
  floodFill(x + 1, y);  // Move Down
  floodFill(x - 1, y);  // Move Up
  floodFill(x, y + 1);  // Move Right
  floodFill(x, y - 1);  // Move Left
}

// Function to retrace the path back to the start position
void retracePath() {
  for (int i = historyIndex - 1; i >= 0; i--) {
    String reverseMovement = movementHistory[i];
    if (reverseMovement == "forward") {
      moveBackward();
    } else if (reverseMovement == "backward") {
      moveForward();
    } else if (reverseMovement == "left") {
      turnRight();
    } else if (reverseMovement == "right") {
      turnLeft();
    }

    encoderCountsLeft = 0;
    encoderCountsRight = 0;
    while (encoderCountsLeft < targetEncoderCounts && encoderCountsRight < targetEncoderCounts) {
      applyPID();  // Adjust speed based on PID
    }

    stopCar();
  }
}

// Function to perform the 180-degree turn before returning
void fullTurn() {
  turnLeft();
  delay(2000);  // Perform 180-degree turn (adjust timing as necessary)
  stopCar();
}

void setup() {
  // Initialize motor pins
  pinMode(IN1, OUTPUT);
  pinMode(IN2, OUTPUT);
  pinMode(IN3, OUTPUT);
  pinMode(IN4, OUTPUT);
  pinMode(PWMA, OUTPUT);
  pinMode(PWMB, OUTPUT);
  pinMode(STBY, OUTPUT);

  // Initialize encoder pins and interrupts
  pinMode(ENCODER_A_LEFT, INPUT);
  pinMode(ENCODER_B_LEFT, INPUT);
  pinMode(ENCODER_A_RIGHT, INPUT);
  pinMode(ENCODER_B_RIGHT, INPUT);

  attachInterrupt(digitalPinToInterrupt(ENCODER_A_LEFT), encoderLeftISR, RISING);
  attachInterrupt(digitalPinToInterrupt(ENCODER_A_RIGHT), encoderRightISR, RISING);

  // Start the motors
  digitalWrite(STBY, LOW);  // Enable motor driver

  // Use flood fill to find the shortest path to the goal
  floodFill(currentX, currentY);

  // After reaching the destination, perform a 180-degree turn and return
  fullTurn();
  retracePath();
}

void loop() {
  // Continuously apply the pathfinding and movement logic
  // In practice, you would modify this based on sensor feedback and dynamic obstacles
}
